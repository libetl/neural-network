<html class="mdl-js">
  <head>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.cyan-pink.min.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/getmdl-select/getmdl-select.min.css"
    />
    <script>
      exports = {}
    </script>
    <script
      defer="defer"
      src="https://cdn.jsdelivr.net/npm/regenerator-runtime@0.12.1/runtime.js"
    ></script>
    <script defer="defer" src="https://code.getmdl.io/1.3.0/material.js"></script>
    <script
      defer="defer"
      src="https://cdn.jsdelivr.net/npm/getmdl-select/getmdl-select.min.js"
    ></script>
    <script defer="defer" src="./network.js"></script>
    <style>
      .training-card-wide.mdl-card {
        width: 256px;
      }

      .training-card-wide > .mdl-card__title {
        color: #fff;
        height: 176px;
        background: url('https://d33wubrfki0l68.cloudfront.net/f9911f02f59d5dea55b81849d258dafea6172bfb/c52a2/images/css/blend-modes/sky.jpg')
          center / cover;
        background-blend-mode: soft-light;
      }

      .training-card-wide > .mdl-card__menu {
        color: #fff;
      }

      .parameters-card-wide.mdl-card {
        width: 256px;
      }

      .parameters-card-wide > .mdl-card__title {
        color: #fff;
        height: 176px;
        background: url('https://i.pinimg.com/originals/fc/df/27/fcdf27152f63402538b11a9c99a8f598.jpg')
          center / cover;
        background-blend-mode: soft-light;
      }

      .parameters-card-wide > .mdl-card__menu {
        color: #fff;
      }

      .canvas-card-image.mdl-card {
        width: 100%;
        height: 100%;
      }

      .canvas-card-image > .mdl-card__actions {
        height: 52px;
        padding: 16px;
        background: rgba(0, 0, 0, 0.2);
      }

      .canvas-card-image__filename {
        color: #fff;
        font-weight: bold;
        font-size: 24px;
        font-weight: 500;
      }
    </style>
    <title>Neural Network</title>
  </head>

  <body>
    <div class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
      <header class="mdl-layout__header">
        <div class="mdl-layout__header-row">
          <img src="https://i.gifer.com/XDZT.gif" width="48" height="48" />
          <span class="mdl-layout-title">Neural network</span>
          <div class="mdl-layout-spacer"></div>
          <nav class="mdl-navigation mdl-layout--large-screen-only"></nav>
        </div>
      </header>
      <main
        class="mdl-layout__content"
        style="
          display: flex;
          flex-direction: row;
          margin-left: 2%;
          margin-top: 1%;
          width: 96%;
          height: 100%;
        "
      >
        <div class="training-card-wide mdl-card mdl-shadow--2dp">
          <div class="mdl-card__title">
            <h2 class="mdl-card__title-text">Train new model</h2>
          </div>
          <div class="mdl-card__supporting-text">
            Before playing with your model, you should train it with a theory
          </div>
          <div class="mdl-grid">
            <div class="mdl-cell mdl-cell--4-col" style="align-self: center;">Theory</div>
            <div class="mdl-cell mdl-cell--6-col">
              <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
                <input
                  class="mdl-textfield__input"
                  type="text"
                  id="theory"
                  onkeypress="currentNetwork[0] = undefined"
                  onkeyup="updateTheory()"
                />
                <label class="mdl-textfield__label" for="theory">x^2 + y^2 &lt; 1</label>
              </div>
            </div>
            <div class="mdl-cell mdl-cell--4-col" style="align-self: center;">Training size</div>
            <div class="mdl-cell mdl-cell--6-col">
              <input
                class="mdl-slider mdl-js-slider"
                id="trainingSize"
                type="range"
                min="100"
                max="10000"
                value="500"
                tabindex="0"
              />
            </div>
            <div class="mdl-cell mdl-cell--4-col" style="align-self: center;">
              Variables amplitude
            </div>
            <div class="mdl-cell mdl-cell--6-col">
              <input
                class="mdl-slider mdl-js-slider"
                id="variablesAmplitude"
                type="range"
                min="1"
                max="20"
                value="5"
                tabindex="0"
              />
            </div>
            <div class="mdl-cell mdl-cell--1-col">&nbsp;</div>
            <div class="mdl-cell mdl-cell--11-col" style="align-self: flex-end;">
              <div class="mdl-grid">
                <div class="mdl-cell mdl-cell--3-col">
                  <button
                    class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect"
                    onclick="eraseCurrentNetwork()"
                    id="actionEraseCurrentNetwork"
                  >
                    <i class="material-icons" id="actionIconHighlightOff">highlight_off</i>
                  </button>
                </div>
                <div class="mdl-cell mdl-cell--3-col">
                  <button
                    class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored"
                    onclick="continuousTraining()"
                    id="actionTraining"
                  >
                    <i class="material-icons" id="actionIconRowing">rowing</i>
                  </button>
                </div>
                <div class="mdl-cell mdl-cell--3-col">
                  <button
                    class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored"
                    onclick="training()"
                    id="actionOneTraining"
                  >
                    <i class="material-icons" id="actionIconTraining">model_training</i>
                  </button>
                </div>
                <div class="mdl-cell mdl-cell--3-col">&nbsp;</div>
                <div class="mdl-cell mdl-cell--4-col">
                  <input
                    type="file"
                    style="display: none;"
                    id="fileinput"
                    onchange="importWeightsAndBiasesFromFile()"
                  />
                  <button
                    class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent"
                    onclick="document.getElementById('fileinput').click()"
                    id="actionImport"
                  >
                    import
                  </button>
                </div>
                <div class="mdl-cell mdl-cell--3-col">
                  <button
                    class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-button--accent"
                    disabled="disabled"
                    onclick="weightsAndBiases()"
                    id="actionWeightsAndBiases"
                  >
                    weights&biases
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div style="flex-grow: 1;">
          <div class="canvas-card-image mdl-card mdl-shadow--2dp">
            <div
              class="mdl-card__title mdl-card--expand"
              style="padding: 0; margin: 0; border-bottom: 0;"
            >
              <canvas
                id="canvas"
                style="
                  width: 100%;
                  margin-bottom: -50px;
                  padding-top: 50px;
                  height: 100%;
                  box-shadow: 0 0px 0px 0 rgba(0, 0, 0, 0);
                "
                class="mdl-shadow--2dp"
              >
              </canvas>
            </div>
            <div class="mdl-card__actions" style="backdrop-filter: blur(2px);">
              <div class="mdl-card__supporting-text">
                Blue is the value computed by the theory and green is the prediction by the model
              </div>
            </div>
          </div>
        </div>
        <div style="display: flex; flex-direction: row;">
          <div class="parameters-card-wide mdl-card mdl-shadow--2dp">
            <div class="mdl-card__title">
              <h2 class="mdl-card__title-text">Be more accurate</h2>
            </div>
            <div class="mdl-card__supporting-text">
              Specify the parameters and hidden layers you want to take in consideration to train
              the model
            </div>
            <div class="mdl-grid">
              <div class="mdl-cell mdl-cell--5-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label getmdl-select"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input
                    type="text"
                    class="mdl-textfield__input"
                    id="layer1"
                    onchange="currentNetwork[0] = undefined"
                  />
                  <input type="hidden" value="" name="layer1" />
                  <label for="layer1" class="mdl-textfield__label">Hidden L1</label>
                  <ul
                    id="layer1Choices"
                    for="layer1"
                    class="mdl-menu mdl-menu--bottom-left mdl-js-menu"
                  >
                    <li class="mdl-menu__item" data-val="" data-selected="true">None</li>
                    <li class="mdl-menu__item" data-val="1">1 Neuron</li>
                    <li class="mdl-menu__item" data-val="2">2 Neurons</li>
                    <li class="mdl-menu__item" data-val="3">3 Neurons</li>
                    <li class="mdl-menu__item" data-val="4">4 Neurons</li>
                  </ul>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--5-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label getmdl-select"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input
                    type="text"
                    value=""
                    class="mdl-textfield__input"
                    id="layer2"
                    readonly
                    onchange="currentNetwork[0] = undefined"
                  />
                  <input type="hidden" value="" name="layer2" />
                  <label for="layer2" class="mdl-textfield__label">Hidden L2</label>
                  <ul
                    id="layer2Choices"
                    for="layer2"
                    class="mdl-menu mdl-menu--bottom-left mdl-js-menu"
                  >
                    <li class="mdl-menu__item" data-val="" data-selected="true">None</li>
                    <li class="mdl-menu__item" data-val="1">1 Neuron</li>
                    <li class="mdl-menu__item" data-val="2">2 Neurons</li>
                    <li class="mdl-menu__item" data-val="3">3 Neurons</li>
                    <li class="mdl-menu__item" data-val="4">4 Neurons</li>
                  </ul>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--10-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label getmdl-select"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input
                    type="text"
                    value=""
                    class="mdl-textfield__input"
                    id="activation"
                    readonly
                  />
                  <input
                    type="hidden"
                    value=""
                    name="activation"
                    onchange="currentNetwork[0] = undefined"
                  />
                  <label for="activation" class="mdl-textfield__label">Activation</label>
                  <ul for="activation" class="mdl-menu mdl-menu--bottom-left mdl-js-menu">
                    <li class="mdl-menu__item" data-val="sigmoid" data-selected="true">Sigmoid</li>
                    <li class="mdl-menu__item" data-val="rectifiedLinearUnit">ReLU</li>
                    <li class="mdl-menu__item" data-val="exponentialLinearUnit">eLU</li>
                  </ul>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--4-col" style="align-self: top;">Param 1</div>
              <div class="mdl-cell mdl-cell--6-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input
                    class="mdl-textfield__input"
                    type="text"
                    id="parameter1"
                    value="x"
                    onkeypress="currentNetwork[0] = undefined"
                  />
                  <label class="mdl-textfield__label" for="theory">example : |x| or x^2</label>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--4-col" style="align-self: top;">Param 2</div>
              <div class="mdl-cell mdl-cell--6-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input
                    class="mdl-textfield__input"
                    type="text"
                    id="parameter2"
                    value="y"
                    onkeypress="currentNetwork[0] = undefined"
                  />
                  <label class="mdl-textfield__label" for="theory">example : |y| or y^2</label>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--4-col" style="align-self: top;">Param 3</div>
              <div class="mdl-cell mdl-cell--6-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input class="mdl-textfield__input" type="text" id="parameter3" value="" />
                  <label class="mdl-textfield__label" for="theory">example : x + y</label>
                </div>
              </div>
              <div class="mdl-cell mdl-cell--4-col" style="align-self: top;">Param 4</div>
              <div class="mdl-cell mdl-cell--6-col">
                <div
                  class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"
                  style="margin-bottom: -20px; margin-top: -20px;"
                >
                  <input class="mdl-textfield__input" type="text" id="parameter4" value="" />
                  <label class="mdl-textfield__label" for="theory">example : x * y</label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
    <script type="text/javascript" language="javascript" defer>
      const currentNetwork = []
      const continuousTrainingInterval = []
      class Grid {
        constructor(element, { width, height }) {
          const canvas = element
          this.context = canvas.getContext('2d')
          this.zoom = 1 / 40
          this.width = parseInt(width)
          this.height = parseInt(height)
          canvas.width = this.width
          canvas.height = this.height
        }

        clearRect() {
          this.context.clearRect(0, 0, this.width, this.height)
          return this
        }

        maxX() {
          return 1 / (this.zoom * 2)
        }

        minX() {
          return -1 / (this.zoom * 2)
        }

        maxY() {
          return (this.maxX() * this.height) / this.width
        }

        minY() {
          return (this.minX() * this.height) / this.width
        }

        xCoords(x) {
          return ((x - this.minX()) / (this.maxX() - this.minX())) * this.width
        }

        yCoords(y) {
          return this.height - ((y - this.minY()) / (this.maxY() - this.minY())) * this.height
        }

        xTickDelta() {
          return 1
        }

        yTickDelta() {
          return 1
        }

        drawAxes() {
          this.context.save()
          this.context.strokeStyle = '#000000'
          this.context.linewidth = 2
          // +Y axis
          this.context.beginPath()
          this.context.moveTo(this.xCoords(0), this.yCoords(0))
          this.context.lineTo(this.xCoords(0), this.yCoords(this.maxY()))
          this.context.stroke()

          this.context.beginPath()
          this.context.moveTo(this.xCoords(0), this.yCoords(0))
          this.context.lineTo(this.xCoords(0), this.yCoords(this.minY()))
          this.context.stroke()

          let delta = this.yTickDelta()
          for (let i = 1; i * delta < this.maxY(); ++i) {
            this.context.beginPath()
            this.context.moveTo(this.xCoords(0) - 5, this.yCoords(i * delta))
            this.context.lineTo(this.xCoords(0) + 5, this.yCoords(i * delta))
            this.context.stroke()
          }

          delta = this.yTickDelta()
          for (let i = 1; i * delta > this.minY(); --i) {
            this.context.beginPath()
            this.context.moveTo(this.xCoords(0) - 5, this.yCoords(i * delta))
            this.context.lineTo(this.xCoords(0) + 5, this.yCoords(i * delta))
            this.context.stroke()
          }

          this.context.beginPath()
          this.context.moveTo(this.xCoords(0), this.yCoords(0))
          this.context.lineTo(this.xCoords(this.maxX()), this.yCoords(0))
          this.context.stroke()

          this.context.beginPath()
          this.context.moveTo(this.xCoords(0), this.yCoords(0))
          this.context.lineTo(this.xCoords(this.minX()), this.yCoords(0))
          this.context.stroke()

          delta = this.xTickDelta()
          for (let i = 1; i * delta < this.maxX(); ++i) {
            this.context.beginPath()
            this.context.moveTo(this.xCoords(i * delta), this.yCoords(0) - 5)
            this.context.lineTo(this.xCoords(i * delta), this.yCoords(0) + 5)
            this.context.stroke()
          }

          delta = this.xTickDelta()
          for (var i = 1; i * delta > this.minX(); --i) {
            this.context.beginPath()
            this.context.moveTo(this.xCoords(i * delta), this.yCoords(0) - 5)
            this.context.lineTo(this.xCoords(i * delta), this.yCoords(0) + 5)
            this.context.stroke()
          }
          this.context.restore()
          return this
        }

        drawCircle(x, y, radius, color) {
          this.context.strokeStyle = color
          this.context.beginPath()
          this.context.arc(this.xCoords(x), this.yCoords(y), radius, 0, 2 * Math.PI, true)
          this.context.stroke()
          return this
        }

        writeText(text) {
          this.context.strokeStyle = '#000000'
          this.context.font = '20px Roboto'
          this.context.fillText(text, this.width - (text || '').length * 10, 15)
          return this
        }

        redraw(activation, theory, remainingCost) {
          this.clearRect()
          if (activation || theory) {
            for (let x = this.minX(); x <= this.maxX(); x += 0.1) {
              for (let y = this.minY(); y <= this.maxY(); y += 0.1) {
                const indexX = Math.floor((x - this.minX()) * 10)
                const indexY = Math.floor((y - this.minY()) * 10)
                if (
                  activation &&
                  activation[indexX][indexY] &&
                  activation[indexX][indexY].activated
                ) {
                  const valueInHex = activation[indexX][indexY].confidence
                    .toString(16)
                    .padStart(2, '0')
                  const invValueInHex = (256 - activation[indexX][indexY].confidence)
                    .toString(16)
                    .padStart(2, '0')
                  this.drawCircle(x, y, 1, `#${invValueInHex}${valueInHex}00`)
                }
                if (theory && theory[indexX][indexY]) {
                  this.drawCircle(x, y, 0.1, '#0000FF')
                }
              }
            }
          }
          if (remainingCost)
            this.writeText(`Remaining cost : ${Math.round(remainingCost * 100) / 100}`)
          this.drawAxes()
          return this
        }
      }
      const theGrid = new Grid(
        document.getElementById('canvas'),
        window.getComputedStyle(document.getElementById('canvas'))
      ).redraw()

      const eraseCurrentNetwork = function (network) {
        currentNetwork[0] = undefined
      }.bind(this, currentNetwork)

      const updateTheory = function (grid) {
        const theoryAsJS = toJavascriptExpr(document.getElementById('theory').value)
        let theoryFunction
        try {
          theoryFunction = eval(`({x,y}) => ${theoryAsJS.trim() || 'false'} ? [1] : [0]`)
          document.getElementById('actionTraining').disabled = false
          document.getElementById('actionOneTraining').disabled = false
        } catch (e) {
          document.getElementById('actionTraining').disabled = true
          document.getElementById('actionOneTraining').disabled = true
        }
        grid.redraw(undefined, getTheoryBitmap(grid, theoryFunction))
      }.bind(this, theGrid)

      const importWeightsAndBiasesFromFile = function (grid, network) {
        if (
          !document.getElementById('fileinput').files ||
          !document.getElementById('fileinput').files.length
        )
          return
        const fileReader = new FileReader()
        fileReader.onload = () => {
          const { weightsAndBiases, parameters, theory, layersLength } = JSON.parse(
            fileReader.result
          )
          document.getElementById('parameter1').value = (parameters && parameters[0]) || ''
          document.getElementById('parameter2').value = (parameters && parameters[1]) || ''
          document.getElementById('parameter3').value = (parameters && parameters[2]) || ''
          document.getElementById('parameter4').value = (parameters && parameters[3]) || ''
          document.getElementById('theory').value = theory
          document.getElementById('layer1').value =
            layersLength.length > 2
              ? `${layersLength[1]} Neuron${layersLength[1] > 1 ? 's' : ''}`
              : 'None'
          Array.from(document.getElementById('layer1Choices').getElementsByTagName('li')).map(
            (e, i) => {
              const value = layersLength.length > 2 ? layersLength[1] === i : i === 0
              e.dataset['selected'] = `${value}`
              e.selected = value
              if (value) e.classList.add('selected')
              else e.classList.remove('selected')
            }
          )
          Array.from(document.getElementById('layer2Choices').getElementsByTagName('li')).map(
            (e, i) => {
              const value = layersLength.length > 3 ? layersLength[2] === i : i === 0
              e.dataset['selected'] = `${value}`
              e.selected = value
              if (value) e.classList.add('selected')
              else e.classList.remove('selected')
            }
          )
          document.getElementById('layer2').value =
            layersLength.length > 3
              ? `${layersLength[2]} Neuron${layersLength[2] > 1 ? 's' : ''}`
              : 'None'
          network[0] = networkBuiltFromDOM().apply(weightsAndBiases)
          const theoryAsJS = toJavascriptExpr(theory)
          const theoryFunction = eval(`({x,y}) => ${theoryAsJS.trim() || 'false'} ? [1] : [0]`)
          grid.redraw(getActivationBitmap(grid, network[0]), getTheoryBitmap(grid, theoryFunction))
          document.getElementById('actionWeightsAndBiases').disabled = false
        }
        fileReader.readAsText(document.getElementById('fileinput').files[0])
        document.getElementById('fileinput').value = ''
      }.bind(this, theGrid, currentNetwork)

      const weightsAndBiases = function (network) {
        const weightsAndBiases = network[0].getWeightsAndBiases()
        const parameters = [
          document.getElementById('parameter1').value,
          document.getElementById('parameter2').value,
          document.getElementById('parameter3').value,
          document.getElementById('parameter4').value
        ]
          .filter(v => v)
          .map(e => ' ' + e + ' ')
        const theory = ' ' + document.getElementById('theory').value + ' '
        const layersLength = network[0].neurons.map(l => l.length)
        const link = document.createElement('a')
        link.style.display = 'none'
        link.href = `data:application/json,${JSON.stringify({
          weightsAndBiases,
          parameters,
          theory,
          layersLength
        })}`
        link.download = 'weightsAndBiases.json'
        document.body.appendChild(link)
        link.click()
      }.bind(this, currentNetwork)

      const continuousTraining = function (grid, whereToSave, interval) {
        if (interval[0]) {
          clearInterval(interval[0])
          interval[0] = undefined
          document.getElementById('actionIconRowing').innerText = 'rowing'
          document.getElementById('actionOneTraining').disabled = false
          return
        }
        document.getElementById('actionIconRowing').innerText = 'stop'
        document.getElementById('actionOneTraining').disabled = true
        let inprogress = false
        document.getElementById('trainingSize').value = '100'
        interval[0] = setInterval(() => {
          if (!inprogress) {
            inprogress = true
            training(grid, whereToSave).then(() => {
              inprogress = false
            })
          }
        }, 200)
      }.bind(this, theGrid, currentNetwork, continuousTrainingInterval)

      const training = function (grid, whereToSave) {
        document.body.style.cursor = 'wait'
        return train(
          networkBuiltFromDOM(),
          ' ' + document.getElementById('theory').value + ' ',
          document.getElementById('trainingSize').value,
          document.getElementById('variablesAmplitude').value
        ).then(
          ({
            theory,
            trainingResult: { remainingCost, remainingCostList, trainedNetwork: network }
          }) => {
            const activation = getActivationBitmap(grid, network)
            const theoryResult = getTheoryBitmap(grid, theory)
            whereToSave[0] = network
            document.getElementById('actionWeightsAndBiases').disabled = false
            grid.redraw(activation, theoryResult, remainingCost)
            document.body.style.cursor = 'pointer'
          }
        )
      }.bind(this, theGrid, currentNetwork)

      function getActivationBitmap(grid, network) {
        let sum = 0
        for (let x = grid.minX(); x <= grid.maxX(); x += 0.1) {
          for (let y = grid.minY(); y <= grid.maxY(); y += 0.1) {
            sum += network.process({
              x,
              y
            })[0]
          }
        }
        const average = sum / ((grid.maxX() - grid.minX()) * 10 * (grid.maxY() - grid.minY()) * 10)
        return Array(Math.ceil((grid.maxX() - grid.minX()) * 10))
          .fill(Array(Math.ceil((grid.maxY() - grid.minY()) * 10)).fill())
          .map((row, i) =>
            row.map((cell, j) => {
              const value = network.process({
                x: grid.minX() + i * 0.1,
                y: grid.minY() + j * 0.1
              })[0]
              return {
                activated: value >= average && value > 1e-10,
                confidence: Math.min(255, Math.max(0, Math.floor(value * 256)))
              }
            })
          )
      }

      function getTheoryBitmap(grid, theory) {
        return Array(Math.ceil((grid.maxX() - grid.minX()) * 10))
          .fill(Array(Math.ceil((grid.maxY() - grid.minY()) * 10)).fill())
          .map((row, i) =>
            row.map(
              (cell, j) =>
                theory({
                  x: grid.minX() + i * 0.1,
                  y: grid.minY() + j * 0.1
                })[0] >= 1
            )
          )
      }

      function toJavascriptExpr(expr) {
        return expr
          .replace(/ <> /g, ' !== ')
          .replace(/ = /g, ' === ')
          .replace(/</g, ' < ')
          .replace(/>/g, ' > ')
          .replace(/([+*/-])/g, ' $1 ')
          .replace(/([\s]+)(cos|sin|tan|sqrt)\(/g, '$1Math.$2\(')
          .replace(/e\^([^\s]+)/g, 'Math.exp($1)')
          .replace(/([^\s]+)\^([^\s]+)/g, 'Math.pow($1, $2)')
          .replace(/\|([^|]+)\|/g, 'Math.abs($1)')
      }

      const networkBuiltFromDOM = () =>
        new Network(
          inputToNetworkConstructorParams(
            [
              document.getElementById('parameter1').value,
              document.getElementById('parameter2').value,
              document.getElementById('parameter3').value,
              document.getElementById('parameter4').value
            ]
              .filter(v => v)
              .map(e => ' ' + e + ' '),
            document.getElementById('layer1').value,
            document.getElementById('layer2').value,
            document.getElementsByName('activation')[0].value
          )
        )

      const inputToNetworkConstructorParams = (
        parametersAsExprs,
        layer1,
        layer2,
        activationFunction
      ) => {
        const parametersAsJS = parametersAsExprs.map(p => toJavascriptExpr(p))
        const parameters = parametersAsJS.map((param, i) => eval('({x,y}) => ' + parametersAsJS[i]))
        const numberByLayer = [parameters.length]
          .concat(layer1 && layer1 !== 'None' ? Array(1).fill(parseInt(layer1)) : [])
          .concat(layer2 && layer2 !== 'None' ? Array(1).fill(parseInt(layer2)) : [])
          .concat([1])
        return {
          numberByLayer,
          activationFunction,
          randomInit: true,
          parameters
        }
      }

      const train = function (
        currentNetwork,
        networkBuiltFromDOM,
        theoryAsExpr,
        trainingSize,
        variablesAmplitudeAsString
      ) {
        const variablesAmplitude = parseInt(variablesAmplitudeAsString)
        const theoryAsJS = toJavascriptExpr(theoryAsExpr)
        const theory = eval(`({x,y}) => ${theoryAsJS.trim() || 'false'} ? [1] : [0]`)
        const inputs = new Array(parseInt(trainingSize))
          .fill()
          .map((_, i) => {
            const amplitude =
              i < trainingSize / 3 ? 5 : i < trainingSize / 2 ? 10 : variablesAmplitude
            return {
              x: Math.floor(Math.random() * amplitude * 100 - (amplitude * 100) / 2) / 100,
              y: Math.floor(Math.random() * amplitude * 100 - (amplitude * 100) / 2) / 100
            }
          })
          .sort(() => Math.random() - 0.5)
        return new Promise(resolve => {
          const network = currentNetwork[0] || networkBuiltFromDOM
          resolve({
            theory,
            trainingResult: network.trainAndGetGradientDescent({
              inputs,
              theory
            })
          })
        })
      }.bind(this, currentNetwork)
    </script>
  </body>
</html>
